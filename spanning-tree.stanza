defpackage spanning-tree :
  import core
  import collections
  import math
  import union-find
  import geom
  import delaunay with :
    prefix( Edge ) => del-

defn abs (v:V2f) : V2f(abs(x(v)), abs(y(v)))
defn map (f:Float -> Float, v:V2f) : V2f(f(x(v)), f(y(v)))

public defstruct Edge <: Hashable & Equalable :
  a : Int
  b : Int

defmethod equal? (e0:Edge, e1:Edge) :
  a(e0) == a(e1) and b(e0) == b(e1) 

defmethod hash (e:Edge) :
  hash(a(e)) + 7 * hash(b(e))

defmethod print (o:OutputStream, e:Edge) :
  print(o, "EDGE(%_, %_)" % [a(e), b(e)])

defn length (points:Tuple<V2f>, e:Edge) -> Float :
  magnitude(points[a(e)] - points[b(e)])

public defstruct IntGraph :
  id : Int
  nbrs : Vector<Int>

defmethod print (o:OutputStream, e:IntGraph) :
  print(o, "IntGraph(%_, %__)" % [id(e), nbrs(e)])

defn IntGraph (point:Int) : IntGraph(point, Vector<Int>())

public defstruct SpanningGraph :
  points : Tuple<V2f>
  graphs : Tuple<IntGraph>

defn edges (tree:SpanningGraph) -> Seqable<Edge> :
  val visited? = HashSet<Int>()
  generate<Edge> :
    let loop (g:Int = 0) :
      add(visited?, g)
      for nbr in nbrs(graphs(tree)[g]) do :
        if not visited?[nbr] :
          yield(Edge(g, nbr))
          loop(nbr)

defmethod print (o:OutputStream, e:SpanningGraph) :
  print(o, "SpanningGraph(%_, %_, %_)" % [points(e), graphs(e)])

defn length (tree:SpanningGraph) -> Float :
  sum(seq(length{points(tree), _}, edges(tree)))

public defn SpanningGraph (ipoints:Seqable<V2f>, seed-edges:Seqable<Edge>) -> SpanningGraph :
  val points = to-tuple $ ipoints
  if length(points) == 0 :
    SpanningGraph([], [] as Tuple<IntGraph>)
  else :
    ;; println("SPANNING-TREE %_" % [length(points)])
    ;; val edges = to-tuple $ lazy-qsort(length{points, _}, all-edges(points))
    ;; val log2n = max(4, ceil-log2(length(points)) - 2)
    ;; println("LOG2N %_" % [log2n])
    val verts = to-tuple $ seq(Vertex, points)
    val vert-mapper = to-inttable<Int> $ for (vert in verts, i in 0 to false) seq : id(vert) => i
    val v2f-edges = edges(Subdivision(verts))
    ;; println("DELAUNAY")
    val unsorted-edges = generate<Edge> :
      for e in v2f-edges do :
        ;; println("e %_ ORG %_ DEST %_" % [e, key?(edge-mapper, org(e)), key?(edge-mapper, dest(e))])
        if key?(vert-mapper, id(org(e))) and key?(vert-mapper, id(dest(e))) :
          yield(Edge(vert-mapper[id(org(e))], vert-mapper[id(dest(e))]))
    val edges = to-tuple $ cat(seed-edges, lazy-qsort(length{points, _}, unsorted-edges))
    ;; println("SORTED EDGES")
    val graphs = to-tuple $ for i in 0 to length(points) seq : IntGraph(i)
    val sets = to-tuple $ for i in 0 to length(points) seq : #UFSet<Int>(i, i, 1)
    ;; for edge in edges do :
    ;;   println("EDGE %_ LENGTH %_" % [edge, length(points, edge)])
    ;; for (point in points, i in 0 to false) do :
    ;;   println("%_: %_" % [i, point])
    label<False> return :
      for edge in edges do :
        ;; println("CONSIDERING EDGE %_ SETS %_ , %_" % [edge, id(root(sets[a(edge)])), id(root(sets[b(edge)]))])
        if root(sets[a(edge)]) != root(sets[b(edge)]) :
          add(nbrs(graphs[a(edge)]), b(edge))
          add(nbrs(graphs[b(edge)]), a(edge))
          merge!(sets[a(edge)], sets[b(edge)])
          return(false) when one-set?(sets)
    ;; println("DONE")
    SpanningGraph(points, graphs)

public defstruct IntTree :
  idx      : Int
  children : Tuple<IntTree>

public defstruct SpanningTree :
  points : Tuple<V2f>
  tree   : IntTree

defn SpanningTree (graph:SpanningGraph) -> SpanningTree :
  val visited? = HashSet<Int>()
  val tree = let loop (g:Int = 0) :
    add(visited?, g)
    val elts = generate<IntTree> :
      for nbr in nbrs(graphs(graph)[g]) do :
        yield(loop(nbr)) when not visited?[nbr]
    IntTree(g, to-tuple $ elts)
  SpanningTree(points(graph), tree)

public defn SpanningTree (points:Seqable<V2f>, seed-edges:Seqable<Edge>) -> SpanningTree :
  SpanningTree(SpanningGraph(points, seed-edges))

public defn SpanningTree (points:Seqable<V2f>) -> SpanningTree :
  SpanningTree(SpanningGraph(points, []))

public defn dump (st:SpanningTree) :
  let loop (t:IntTree = tree(st), depth:Int = 0) :
    for i in 0 to depth do : print("  ")
    println("%_: %_" % [idx(t), points(st)[idx(t)]])
    for child in children(t) do :
      loop(child, depth + 1)

public defn id-segments (st:SpanningTree) -> Seqable<V2i> :
  generate<V2i> :
    let loop (t:IntTree = tree(st)) :
      for child in children(t) do :
        yield(V2i(idx(t), idx(child)))
        loop(child)

public defn id-tour (st:SpanningTree) -> Seqable<V2i> :
  generate<V2i> :
    let loop (t:IntTree = tree(st)) :
      for child in children(t) do :
        yield(V2i(idx(t), idx(child)))
        loop(child)
        yield(V2i(idx(child), idx(t)))

public defn segments (st:SpanningTree) -> Seqable<LineSegment2f> :
  seq(fn (s) : LineSegment2f(points(st)[s[0]], points(st)[s[1]]), id-segments(st))

;; 
