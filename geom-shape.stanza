defpackage geom/shape :
  import core
  import math
  import geom/vec
  import geom/angle
  import geom/mat
  import geom/box
  import geom/pose
  import geom/poseable
  import geom/bounded
  import geom/geom

;;; ANYSHAPE

public defstruct AnyShapeState :
  name : False|Symbol
  color : V4d
  tags : Tuple<Symbol>
  poses : Tuple<KeyValue<Symbol,Mat44d>>

public defn default-anyshape-state () : AnyShapeState(false, WHITE, [], [])

val @doc-anyshape = "ANYSHAPE -- leaf poseables allowing more transformations"

public deftype AnyShape <: Poseable
public defmulti state (a:AnyShape) -> AnyShapeState
public defmulti clone<?T> (shape:?T&AnyShape, state:AnyShapeState) -> T
public defmethod name (p:AnyShape) : name(state(p))
public defmethod color (p:AnyShape) : color(state(p))
public defmethod tags (p:AnyShape) : tags(state(p))
public defmethod poses (p:AnyShape) : poses(state(p))

defmethod any-shapes (p:AnyShape) : [p] ;; DEFAULT

public defn bit-or (a:AnyShapeState, b:AnyShapeState) -> AnyShapeState :
  AnyShapeState(name(a) when name(a) is Symbol else name(b), color(a),
                to-tuple $ cat(tags(a), tags(b)), to-tuple $ cat(poses(a), poses(b)))

defmethod clone (s:AnyShape, name:False|Symbol, color:V4d, poses:Tuple<KeyValue<Symbol,Mat44d>>, tags:Tuple<Symbol>) :
  clone(s, AnyShapeState(name, color, tags, poses))

public defn add-poses<?T> (s:?T&AnyShape, poses:Tuple<KeyValue<Symbol,Mat44d>>) -> T :
  clone(s, AnyShapeState(name(s), color(s), tags(s), poses))
public defn add-tags<?T> (s:?T&AnyShape, tags:Tuple<Symbol>) -> T :
  clone(s, AnyShapeState(name(s), color(s), tags, poses(s)))

public defn add-min-x-pose<?T> (s:?T&AnyShape, dir:Double) -> T :
  add-poses(s, [`min-x => pose-mat44d(x3d(x(lo(bounds(s)))), y3d(dir *  90.0))])
public defn add-max-x-pose<?T> (s:?T&AnyShape, dir:Double) -> T :
  add-poses(s, [`max-x => pose-mat44d(x3d(x(hi(bounds(s)))), y3d(dir * -90.0))])
public defn add-min-y-pose<?T> (s:?T&AnyShape, dir:Double) -> T :
  add-poses(s, [`min-y => pose-mat44d(y3d(y(lo(bounds(s)))), x3d(dir * -90.0))])
public defn add-max-y-pose<?T> (s:?T&AnyShape, dir:Double) -> T :
  add-poses(s, [`max-y => pose-mat44d(y3d(y(hi(bounds(s)))), x3d(dir *  90.0))])
public defn add-min-z-pose<?T> (s:?T&AnyShape, dir:Double) -> T :
  add-poses(s, [`min-z => pose-mat44d(z3d(z(lo(bounds(s)))), y3d(180.0 when dir == 1.0 else 0.0 ))])
public defn add-max-z-pose<?T> (s:?T&AnyShape, dir:Double) -> T :
  add-poses(s, [`max-z => pose-mat44d(z3d(z(hi(bounds(s)))), y3d(  0.0 when dir == 1.0 else 180.0))])


public defn name (a:AnyShape, b:AnyShape) :
  name(a) when name(a) is Symbol else name(b)

public defn tags (a:AnyShape, b:AnyShape) :
  to-tuple $ unique $ cat(tags(a), tags(b))

public defn poses (a:AnyShape, b:AnyShape) :
  to-tuple $ unique $ cat(poses(a), poses(b))

public defn color (a:AnyShape, b:AnyShape) :
  color(a)

public defn dim-min (d:Double) -> Double : d * -0.5
public defn dim-max (d:Double) -> Double : d *  0.5

public defn dim-min (dim:V3d) -> V3d : V3d(dim-min(x(dim)), dim-min(y(dim)), dim-min(z(dim)))
public defn dim-max (dim:V3d) -> V3d : V3d(dim-max(x(dim)), dim-max(y(dim)), dim-max(z(dim)))

val @doc-shape = "SHAPE -- a solid object"

public deftype Shape <: AnyShape

public defn shapes (any-shapes:Seqable<AnyShape>) -> Seqable<Shape> :
  generate<Shape> : for e in any-shapes do : yield(e as Shape) when e is Shape and area*(dims(bounds(e))) > 0.0

public defn shapes (p:Poseable) : shapes(any-shapes(p))

public var *resolution*:Double = 8.0
public defn set-resolution (r:Double) : *resolution* = r

;; public defmulti slice (z:Double, s:Shape3) -> Shape2
;; public defmulti pixels (z:Double, s:Shape3) -> Pixels
;; public defmulti box (b:Box3d) -> Shape3
;; public defmulti cube (v:V3d) -> Shape3
;; 
;; public defmulti rect (b:Box2f) -> Shape2
;; public defmulti circle (d:Double) -> Shape2
;; public defmulti triangle (a:V2f, b:V2f, c:V2f) -> Shape2
;; public defmulti extrude (h:Double, shape:Shape2) -> Shape3
;; 
;; public defmulti bit-and (a:Shape3, b:Shape3) -> Shape3
;; public defmulti rem (a:Shape3, b:Shape3) -> Shape3
;; public defmulti offset (s:Shape3, o:Double) -> Shape3

public defmulti shape-eval (e) -> Geom
